# 覚えたことを書く

## 名前
* 名前は文字とアンスコで構成される
* 大文字小文字は区別される
* 名前の最初が大文字のものは外部に公開され、パッケージの外から見える
    * 例）fmtパッケージのPrintf
* パッケージ名は常に小文字

## 宣言

* Goプログラムはファイル名が `.go` で終わる1個以上のファイルに保存される
* 各ファイルはそのファイルがどのパッケージの一部であるかを示す `package` 宣言で始まる

## ポインタ

```
x := 1              
p := &x             // pはint型で、xを指している
fmt.Println(*p)     // "1"
*p = 2              // x = 2 と同じ
fmt/Println(x)      // "2"
```



### コードの解析

このコード行が `(true false false)` という結果を出力する理由を一つずつ見ていきましょう。

```go
var x, y int
fmt.Println(&x == &x, &x == &y, &x == nil)
```

- `&x == &x`: これは `true` を返します。なぜなら、`&x` は変数 `x` のアドレスを取得し、それ自体と比較しているためです。同一の変数のアドレスはプログラムの実行中に変わることがないため、常に `true` になります。
- `&x == &y`: これは `false` を返します。`x` と `y` は異なる変数であり、それぞれ異なるメモリアドレスを持っています。したがって、`&x`（`x` のアドレス）と `&y`（`y` のアドレス）を比較すると、それらは異なるため `false` になります。
- `&x == nil`: これは `false` を返します。`&x` は `x` のメモリアドレスを表し、有効なアドレスです。`nil` はポインタが何も指していないことを示しますが、`&x` は有効な変数のアドレスを指しているため、`nil` とはなりません。したがって、この比較は `false` になります。

### 補足

Go言語では、各変数はユニークなメモリアドレスを持ち、`nil` は「何も指していない」ポインタの状態を表します。変数のアドレスを取得する操作（`&` 演算子を使用）は常に有効なアドレスを返すため、`nil` と比較すると常に `false` になります。

この挙動は、Goのポインタとメモリ管理の基本的な原則を示しています。ポインタを使用する際は、これらの原則を理解しておくことが重要です。

はい、ポインタが`nil`になる状況はあります。Go言語において、ポインタが`nil`を指すのは、そのポインタがまだ何も指していない、つまり初期化されていないか、明示的に`nil`に設定された場合です。`nil`ポインタは、"ゼロ値"としても知られており、ポインタ型の変数が宣言されたが、まだ具体的なメモリアドレスを指定されていない状態を表します。

以下に、ポインタが`nil`になるいくつかの典型的な例を示します。

## 1. 変数宣言時のゼロ値

ポインタ型の変数が宣言されただけで、まだ何も割り当てられていない場合、そのポインタのデフォルト値は`nil`です。

```go
var p *int
fmt.Println(p) // "<nil>"を出力
```

## 2. 明示的なnil割り当て

ポインタ変数に明示的に`nil`を割り当てることもできます。

```go
var p *int
p = nil
fmt.Println(p) // "<nil>"を出力
```

## 3. 新しいインスタンスを指さない

`new`キーワードや構造体リテラルを使って新しいインスタンスを作成せずに、ポインタ型の変数を宣言すると、そのポインタは`nil`を指します。

```go
type MyStruct struct {
    Field int
}

var p *MyStruct
fmt.Println(p) // "<nil>"を出力
```

## 4. 関数がnilを返す場合

何らかの理由で処理に失敗したり、条件によっては何も返さないように設計された関数から`nil`が返される場合があります。

```go
func getPointer() *int {
    return nil
}

p := getPointer()
fmt.Println(p) // "<nil>"を出力
```

`nil`ポインタは、まだ有効な値やオブジェクトを指していないことを示すため、`nil`ポインタをデリファレンス（`*p`のようにポインタを通して値にアクセスしようとする操作）すると、ランタイムパニックが発生します。そのため、`nil`ポインタを操作する前には、常に`nil`チェックを行うことが推奨されます。

## echo4 の解説

このプログラムは、コマンドライン引数を処理して、指定されたセパレータで結合した文字列を出力するシンプルなコマンドラインツールです。`flag`パッケージを使用して、ユーザーがコマンドラインオプションを介して動作をカスタマイズできるようにしています。

### プログラムの解説

#### インポート文

```go
import (
	"flag"
	"fmt"
	"strings"
)
```
- `flag`パッケージ: コマンドラインオプションの解析に使用します。
- `fmt`パッケージ: 標準出力への出力に使用します。
- `strings`パッケージ: 文字列の結合に使用します。

#### グローバル変数の定義

```go
var n = flag.Bool("n", false, "omit trailing newline")
var sep = flag.String("s", " ", "separator")
```
- `n`: `-n`オプションを指定すると、出力の末尾に改行を追加しないようにします。デフォルトは`false`です。
- `sep`: `-s`オプションに続けて指定された文字列を、引数間のセパレータとして使用します。デフォルトのセパレータは半角スペース`" "`です。

#### main関数

```go
func main() {
	flag.Parse()
	fmt.Print(strings.Join(flag.Args(), *sep))
	if !*n {
		fmt.Println()
	}
}
```
- `flag.Parse()`: コマンドラインオプションを解析します。この関数が実行されると、`n`と`sep`変数がユーザーが指定したオプションの値に基づいて更新されます。
- `strings.Join(flag.Args(), *sep)`: `flag.Args()`関数で取得したコマンドライン引数（オプションではない部分）を、`sep`で指定されたセパレータを使って結合します。`*sep`は`sep`ポインタのデリファレンスを意味し、実際のセパレータの値を取得します。
- `if !*n { fmt.Println() }`: `-n`オプションが指定されていない場合（つまり、`n`が`false`の場合）、改行を出力します。`*n`は`n`ポインタのデリファレンスを意味し、実際のブール値を取得します。

### 使用例

このプログラムを`go run`で実行する際の例をいくつか示します。

- オプションなしで実行: `go run . arg1 arg2 arg3`
  - 出力: `arg1 arg2 arg3`
- `-s`オプションでセパレータを指定: `go run . -s , arg1 arg2 arg3`
  - 出力: `arg1,arg2,arg3`
- `-n`オプションを指定して末尾の改行を省略: `go run . -n arg1 arg2 arg3`
  - 出力: `arg1 arg2 arg3`（末尾に改行なし）

このプログラムは、コマンドラインオプションの扱い方を学ぶのに適したシンプルな例です。

```
❯ ./echo4 a bc def
a bc def
❯ ./echo4 -s / a bc def
a/bc/def
❯ ./echo4 -n a bc def
a bc def%                                                                                                                                                              
❯ ./echo4 -help
Usage of ./echo4:
  -n    omit trailing newline
  -s string
        separator (default " ")
```

## new 関数

new(T)は、型がTの無名変数を作成し、Tの初期値日して、アドレスを返す

```go
package main

import "fmt"

func main() {
	p := new(int)
	fmt.Println("p:", p)   // アドレス
	fmt.Println("*p:", *p) // "0"
	*p = 2                 //intに2を入れる
	fmt.Println(*p)        // 2
}
```

```
package main

import "fmt"

func main() {
	p := new(int)
	fmt.Println("p:", p)   // アドレス
	fmt.Println("*p:", *p) // "0"
	*p = 2                 //intに2を入れる
	fmt.Println(*p)        // 2

}

```

```
❯ go run ./new.go
p: 0xc000022140
*p: 0
2

```


